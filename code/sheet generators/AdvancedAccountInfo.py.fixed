import os
import csv
from datetime import datetime
from openpyxl.styles import Font, PatternFill, Border, Side

class AdvancedAccountInfo:
    def __init__(self, wb, ws, styles, extract_date_func, apply_border_func):
        self.wb = wb
        self.ws = ws
        self.styles = styles
        self.extract_date = extract_date_func
        self.apply_table_border = apply_border_func
        
    def order_history(self):
        transactions_info = []
        csv_path = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))), "cache", "trading212_history.csv")
        
        if os.path.exists(csv_path):
            with open(csv_path, 'r', encoding='utf-8') as csvfile:
                reader = csv.DictReader(csvfile)
                for row in reader:
                    action = row.get("Action", "")
                    if action.lower() in ["market buy", "market sell", "stop buy", "stop sell", "limit buy", "limit sell"]:
                        try:
                            qty = float(row.get("No. of shares", "0") or 0)
                            price = float(row.get("Price / share", "0") or 0)
                            total = float(row.get("Total", "0") or 0)
                        except ValueError:
                            continue
                            
                        order_type = "Buy" if "buy" in action.lower() else "Sell"
                        
                        transactions_info.append({
                            "dateTime": row.get("Time", ""),
                            "ticker": row.get("Ticker", ""),
                            "name": row.get("Name", ""),
                            "orderType": order_type,
                            "quantity": qty,
                            "pricePerUnit": price,
                            "totalValue": total,
                            "currency": row.get("Currency (Total)", ""),
                            "result": row.get("Result", "0")
                        })
        
        transactions_info.sort(key=lambda x: x.get("dateTime", ""), reverse=True)
        start_col, start_row = 2, 2
        
        # Add search instructions
        instruction_cell = self.ws.cell(row=start_row, column=start_col)
        instruction_cell.value = "ðŸ’¡ Use Excel's filter buttons in the header row to search and filter transactions"
        instruction_cell.font = Font(italic=True, size=12.5)
        instruction_cell.fill = PatternFill(start_color="fff6a8", end_color="fff6a8", fill_type="solid")
        self.ws.merge_cells(start_row=start_row, start_column=start_col, 
                            end_row=start_row, end_column=start_col + 6)
        
        # Title
        title_row = start_row + 1
        title_range = f"B{title_row}:H{title_row}"
        self.ws.merge_cells(title_range)
        title_cell = self.ws[f'B{title_row}']
        title_cell.value = "Detailed Transaction History"
        title_cell.font = Font(bold=True, size=14)
        title_cell.fill = self.styles["dark_grey"]
        for row in self.ws[title_range]:
            for cell in row:
                cell.border = self.styles["title_border"]
        
        # Headers
        headers = ["Date", "Ticker", "Asset Name", "Order Type", "Quantity", "Price/Unit", "Total Value"]
        header_row = title_row + 1
        for col_offset, header in enumerate(headers):
            cell = self.ws.cell(row=header_row, column=start_col + col_offset, value=header)
            cell.fill = self.styles["grey"]
            cell.border = self.styles["table_border"]
            cell.font = Font(bold=True)
        
        # Data rows
        row = header_row + 1
        for tx in transactions_info:
            date = self.extract_date(tx.get("dateTime", ""))
            ticker = tx.get("ticker", "N/A")
            name = tx.get("name", "N/A")
            order_type = tx.get("orderType", "N/A")
            quantity = round(tx.get("quantity", 0), 4)
            price_per_unit = round(tx.get("pricePerUnit", 0), 4)
            total_value = round(tx.get("totalValue", 0), 2)
            
            row_fill = self.styles["green"] if order_type == "Buy" else self.styles["red"] if order_type == "Sell" else self.styles["grey"]
            values = [date, ticker, name, order_type, quantity, price_per_unit, total_value]
            
            for col_offset, val in enumerate(values):
                cell = self.ws.cell(row=row, column=start_col + col_offset, value=val)
                cell.border = self.styles["table_border"]
                if col_offset <= 2:  # Date, Ticker, Name columns
                    cell.fill = self.styles["grey"]
                elif col_offset == 3:  # Order Type column
                    cell.fill = row_fill
                    cell.font = Font(bold=True)
                else:  # Value columns
                    cell.fill = row_fill
            row += 1
        
        # Set column widths
        column_widths = {'B': 15, 'C': 12, 'D': 35, 'E': 12, 'F': 15, 'G': 15, 'H': 15}
        for col_letter, width in column_widths.items():
            self.ws.column_dimensions[col_letter].width = width
        
        last_data_row = row - 1 if transactions_info else header_row
        
        # Apply table border
        self.apply_table_border(ws=self.ws, first_row=start_row, last_row=last_data_row, 
                               first_col=start_col, last_col=start_col + len(headers) - 1)
        
        # Add Excel AutoFilter
        if transactions_info:
            filter_range = f"B{header_row}:E{last_data_row}"
            self.ws.auto_filter.ref = filter_range

    def wait_times_analysis(self):
        buy_transactions = {}
        sell_transactions = []
        csv_path = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))), "cache", "trading212_history.csv")
        
        if os.path.exists(csv_path):
            with open(csv_path, 'r', encoding='utf-8') as csvfile:
                reader = csv.DictReader(csvfile)
                for row_data in reader:
                    action = row_data.get("Action", "")
                    if action.lower() in ["market buy", "market sell", "stop buy", "stop sell", "limit buy", "limit sell"]:
                        time_str = row_data.get("Time", "")
                        ticker = row_data.get("Ticker", "")
                        name = row_data.get("Name", "")
                        
                        try:
                            qty = float(row_data.get("No. of shares", "0") or 0)
                        except ValueError:
                            continue
                            
                        if qty <= 0:
                            continue
                        
                        transaction = {
                            "dateTime": time_str, "ticker": ticker, 
                            "name": name, "quantity": qty, "action": action
                        }
                        
                        if "buy" in action.lower():
                            if ticker not in buy_transactions:
                                buy_transactions[ticker] = []
                            buy_transactions[ticker].append(transaction)
                        elif "sell" in action.lower():
                            sell_transactions.append(transaction)
        
        all_individual_holds = []
        
        for sell_tx in sell_transactions:
            sell_ticker = sell_tx["ticker"]
            if sell_ticker not in buy_transactions:
                continue
                
            sell_name = sell_tx["name"]
            sell_date = sell_tx["dateTime"]
            remaining_sell_qty = sell_tx["quantity"]
            
            sorted_buys = sorted(buy_transactions[sell_ticker], key=lambda x: x["dateTime"])
            
            for buy_tx_original in sorted_buys:
                if remaining_sell_qty <= 0:
                    break
                
                buy_idx = buy_transactions[sell_ticker].index(buy_tx_original)
                buy_qty_available = buy_transactions[sell_ticker][buy_idx]["quantity"]
                
                if buy_qty_available <= 0:
                    continue

                matched_qty = min(remaining_sell_qty, buy_qty_available)
                
                try:
                    buy_dt = datetime.strptime(buy_tx_original["dateTime"].split(" ")[0], "%Y-%m-%d")
                    sell_dt = datetime.strptime(sell_date.split(" ")[0], "%Y-%m-%d")
                    
                    hold_days = (sell_dt - buy_dt).days
                    if hold_days >= 0:
                        all_individual_holds.append({
                            'ticker': sell_ticker, 'name': sell_name, 'days': hold_days
                        })
                        
                    buy_transactions[sell_ticker][buy_idx]["quantity"] -= matched_qty
                    remaining_sell_qty -= matched_qty
                except ValueError:
                    continue
        
        avg_hold_days = 0
        top_3_longest_holds = []
        
        if all_individual_holds:
            avg_hold_days = sum(item['days'] for item in all_individual_holds) / len(all_individual_holds)
            
            ticker_longest_holds = {}
            for hold in all_individual_holds:
                ticker, days = hold['ticker'], hold['days']
                if ticker not in ticker_longest_holds or days > ticker_longest_holds[ticker]['days']:
                    ticker_longest_holds[ticker] = hold
            
            top_3_longest_holds = sorted(ticker_longest_holds.values(), 
                                         key=lambda x: x['days'], reverse=True)[:3]
        
        start_col, start_row = 10, 2
        
        # Title
        title_range = f"J{start_row}:L{start_row}"
        self.ws.merge_cells(title_range)
        title_cell = self.ws[f'J{start_row}']
        title_cell.value = "Hold Time Statistics"
        title_cell.font = Font(bold=True, size=14)
        title_cell.fill = self.styles["dark_grey"]
        
        for r in range(start_row, start_row + 1):
            for c in range(start_col, start_col + 3):
                self.ws.cell(row=r, column=c).border = self.styles["title_border"]
        
        row = start_row + 1
        
        # Average Hold Time row
        blue_fill = PatternFill(start_color="e6f3ff", end_color="e6f3ff", fill_type="solid")
        
        cells = [
            (start_col, "Average Hold Time", self.styles["grey"]),
            (start_col + 1, round(avg_hold_days, 1), blue_fill),
            (start_col + 2, "days", blue_fill)
        ]
        
        for col_offset, value, fill in cells:
            cell = self.ws.cell(row=row, column=col_offset, value=value)
            cell.fill = fill
            cell.border = self.styles["table_border"]
        
        row += 1

        # Sub-header and data for longest held assets
        if top_3_longest_holds:
            # Sub-header
            sub_header_range = f"{chr(64 + start_col)}{row}:{chr(64 + start_col + 2)}{row}"
            self.ws.merge_cells(sub_header_range)
            self.ws.cell(row=row, column=start_col, value="Longest Unique Held Assets:").font = Font(bold=True)
            self.ws.cell(row=row, column=start_col).fill = self.styles["grey"]
            
            for c in range(start_col, start_col + 3):
                self.ws.cell(row=row, column=c).border = self.styles["table_border"]
            
            row += 1

            # Data rows for top 3 longest held assets
            for item in top_3_longest_holds:
                cells = [
                    (start_col, item['ticker'], self.styles["grey"]),
                    (start_col + 1, item['days'], blue_fill),
                    (start_col + 2, "days", blue_fill)
                ]
                
                for col_offset, value, fill in cells:
                    cell = self.ws.cell(row=row, column=col_offset, value=value)
                    cell.fill = fill
                    cell.border = self.styles["table_border"]
                row += 1
        
        # Set column widths
        for col_letter, width in {'J': 35, 'K': 15, 'L': 10}.items():
            self.ws.column_dimensions[col_letter].width = width
        
        # Apply border to entire table
        thin_side = Side(style='thin')
        last_row = row - 1
        
        for r in range(start_row, last_row + 1):
            for c in range(start_col, start_col + 3):
                cell = self.ws.cell(row=r, column=c)
                border = cell.border
                new_border = Border(
                    left=thin_side if c == start_col else border.left,
                    right=thin_side if c == start_col + 2 else border.right,
                    top=thin_side if r == start_row else border.top,
                    bottom=thin_side if r == last_row else border.bottom
                )
                cell.border = new_border
                
        # Store the last row number for use by fee_analysis
        self.last_wait_times_row = last_row

    def fee_analysis(self):
        fee_breakdown = {}
        csv_path = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))), "cache", "trading212_history.csv")
        
        # Add gap of 2 rows from wait_times_analysis
        start_row = getattr(self, 'last_wait_times_row', 0) + 2
        start_col = 10
        
        if os.path.exists(csv_path):
            with open(csv_path, 'r', encoding='utf-8') as csvfile:
                reader = csv.DictReader(csvfile)
                fee_types = [
                    ("Deposit Fee", "Deposit fee"),
                    ("Currency Conversion", "Currency conversion fee"),
                    ("Stamp Duty Tax", "Stamp duty reserve tax"),
                    ("Withholding Tax", "Withholding tax")
                ]
                
                for row in reader:
                    for fee_name, fee_column in fee_types:
                        fee_value = row.get(fee_column, "0")
                        if fee_value and fee_value != "0":
                            try:
                                amount = abs(float(fee_value))
                                if amount > 0:
                                    if fee_name not in fee_breakdown:
                                        fee_breakdown[fee_name] = 0
                                    fee_breakdown[fee_name] += amount
                            except ValueError:
                                continue
        
        total_fees = sum(fee_breakdown.values()) if fee_breakdown else 0
        
        # Create title
        title_range = f"J{start_row}:L{start_row}"
        self.ws.merge_cells(title_range)
        title_cell = self.ws[f'J{start_row}']
        title_cell.value = "Fee Breakdown"
        title_cell.font = Font(bold=True)
        title_cell.fill = self.styles["dark_grey"]
        for row in self.ws[title_range]:
            for cell in row:
                cell.border = self.styles["title_border"]
        
        # Create headers
        headers = ["Fee Type", "Amount", "Currency"]
        header_row = start_row + 1
        for col_offset, header in enumerate(headers):
            cell = self.ws.cell(row=header_row, column=start_col + col_offset, value=header)
            cell.fill = self.styles["grey"]
            cell.border = self.styles["table_border"]
            cell.font = Font(bold=True)
        
        # Add fee data rows
        row = header_row + 1
        for fee_type, amount in sorted(fee_breakdown.items()):
            values = [fee_type, round(amount, 2), "EUR"]
            for col_offset, val in enumerate(values):
                cell = self.ws.cell(row=row, column=start_col + col_offset, value=val)
                cell.border = self.styles["table_border"]
                cell.fill = self.styles["red"]
            row += 1
        
        # Add total row if fees exist
        if fee_breakdown:
            for col_offset, val in enumerate(["TOTAL FEES", round(total_fees, 2), "EUR"]):
                cell = self.ws.cell(row=row, column=start_col + col_offset, value=val)
                cell.border = self.styles["table_border"]
                cell.fill = self.styles["red"]
                cell.font = Font(bold=True)
        
        # Set column widths
        for col_letter, width in {'J': 18, 'K': 12, 'L': 12}.items():
            self.ws.column_dimensions[col_letter].width = width
        
        # Apply border to entire table
        thin_side = Side(style='thin')
        last_data_row = row if fee_breakdown else header_row
        last_col = start_col + len(headers) - 1
        
        for r in range(start_row, last_data_row + 1):
            for c in range(start_col, last_col + 1):
                cell = self.ws.cell(row=r, column=c)
                border = cell.border
                new_border = Border(
                    left=thin_side if c == start_col else border.left,
                    right=thin_side if c == last_col else border.right,
                    top=thin_side if r == start_row else border.top,
                    bottom=thin_side if r == last_data_row else border.bottom
                )
                cell.border = new_border
                
    def generate_sheet(self):
        self.order_history()
        self.wait_times_analysis()
        self.fee_analysis()
